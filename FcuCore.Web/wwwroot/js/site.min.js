/* jQuery Tiny Pub/Sub - v0.7 - 10/27/2011
 * http://benalman.com/
 * Copyright (c) 2011 "Cowboy" Ben Alman; Licensed MIT, GPL */
(function (a) {
    var b = a({});
    a.subscribe = function () { b.on.apply(b, arguments) }, a.unsubscribe = function () { b.off.apply(b, arguments) }, a
        .publish = function () { b.trigger.apply(b, arguments) }
})(jQuery);
(function (window, ko, $) {
    const cbus = {};
    window.cbus = cbus;
    cbus.status = {
        socketConnected: ko.observable(false),
        cbusConnected: ko.observable(false),
        receivedMessagesBuffer: ko.observableArray(),
        showMessages: ko.observable(false),
        toggleDebug: () => cbus.status.showMessages(!cbus.status.showMessages())
    };

    cbus.api = {
        sendApiRequest: (controller, action, data) => {
            $.ajax({
                url: `/api/${controller}/${action}`,
                data: data,
                contentType: 'application/json',
                method: 'POST'
            });
        },
        sendQNN: () => {
            cbus.api.sendApiRequest("Manager", "Communications", '"enumerate"');
        }
    };

    const messageHandlers = [];
    cbus.comms = {
        connect: () => {
            cbus.api.sendApiRequest("Manager", "Communications",'"open"');
        },
        disconnect: () => {
            cbus.api.sendApiRequest("Manager", "Communications",'"close"');
        },
        addHandler: (opCode, handler) => {
            messageHandlers.push({ opCode: opCode, handler: handler });
        }
    };


    const socket = new WebSocket("ws://" + window.location.host + "/ws");
    socket.onmessage = (d) => {
        var msg = JSON.parse(d.data);
        switch (msg.Type) {
            case "cbus":
                cbus.status.receivedMessagesBuffer.push(msg);
                while (cbus.status.receivedMessagesBuffer().length > 20) {
                    cbus.status.receivedMessagesBuffer.shift();
                }
                if (msg.Direction === "received") {
                    var mh = messageHandlers.filter(handler => handler.opCode === msg.Message.OpCode);
                    for (var x = 0; x < mh.length; x++) {
                        mh[x].handler(msg.Message);
                    }
                }

                break;
            case "connection-status":
                cbus.status.cbusConnected(msg.IsConnected);
                break;
            default:
                console.warn("Unknown websocket message received: ", d.data);
        }
    };
    socket.onopen = () => {
        cbus.status.socketConnected(true);
    };
    socket.onclose = () => {
        cbus.status.socketConnected(false);
    };

    //TODO: reconnect socket, handle errors


})(window, ko, jQuery);
function nodeValue(group, nv, node) {
    this.group = group;
    this.nv = nv;
    this.definition = ko.computed(() => {
        if (nv.definition) {
            return nv.definition;
        }

        let targetDefinition;
        nv.definitions.forEach((d) => {
            if (typeof (d.condition) === "function") {
                if (d.condition(node)) {
                    targetDefinition = d.definition;
                }
            }
        });
        return targetDefinition;
    });
    this.value = ko.observable(this.definition().default);
}

function node(config, type) {
    this.nodeType = type;
    this.nodeNumber = config.NodeNumber;
    this.canId = config.CanId;
    this.isConsumerNode = config.IsConsumerNode;
    this.isProducerNode = config.IsProducerNode;
    this.inFlimMode = config.InFlimMode;
    this.supportsBootloader = config.SupportsBootloader;

    this.nodeValues = ko.observableArray();
    type.configGroups.forEach(cg => {
        cg.nodeValues.forEach(nv => {
            this.nodeValues.push(new nodeValue(cg, nv, this));
        });
    });
}

node.prototype.getValuesInGroup = function(group) {
    return this.nodeValues().filter((nv) => nv.group === group);
};

node.prototype.getNodeValue = function(index) {
    const nv = this.nodeValues().find((nv) => nv.nv.index === index);
    if (nv != null) {
        return nv.value();
    }
    return null;
};

(function (cbus) {



    cbus.modules = {
        definitions: {},
        list: ko.observableArray()
    };

    cbus.comms.addHandler(0xB6, (msg) => {
        for (let m in cbus.modules.definitions) {
            const md = cbus.modules.definitions[m];
            if (md.manufacturerId === msg.ManufacturerId && md.moduleId === msg.ModuleId) {
                const n = new node(msg, md);
                cbus.modules.list.remove(m => m.canId === n.canId);
                cbus.modules.list.push(n);
                break;
            }
        }
    });

})(window.cbus);
cbus.modules.definitions["CANACC4"] = {
    manufacturerId: 165,
    moduleId: 8,
    name: "CANACC4",
    configGroups: [
        {
            name: "General",
            nodeValues: [{
                index: 9,
                definition: {
                    name: "Recharge Time",
                    default: 20,
                    type: "numeric"
                }
            }, {
                index: 10,
                definition: {
                    name: "Fire Delay",
                    default: 20,
                    type: "numeric"
                }
            }]
        }, {
            name: "Output Timings",
            nodeValues: [
                {
                    index: 1,
                    definition: {
                        name: "Pulse Duration Output 1 A",
                        default: 5,
                        type: "numeric"
                    }
                }, {
                    index: 2,
                    definition: {
                        name: "Pulse Duration Output 1 B",
                        default: 5,
                        type: "numeric"
                    }
                }, {
                    index: 3,
                    definition: {
                        name: "Pulse Duration Output 2 A",
                        default: 5,
                        type: "numeric"
                    }
                }, {
                    index: 4,
                    definition: {
                        name: "Pulse Duration Output 2 B",
                        default: 5,
                        type: "numeric"
                    }
                }, {
                    index: 5,
                    definition: {
                        name: "Pulse Duration Output 3 A",
                        default: 5,
                        type: "numeric"
                    }
                }, {
                    index: 6,
                    definition: {
                        name: "Pulse Duration Output 3 B",
                        default: 5,
                        type: "numeric"
                    }
                }, {
                    index: 7,
                    definition: {
                        name: "Pulse Duration Output 4 A",
                        default: 5,
                        type: "numeric"
                    }
                }, {
                    index: 8,
                    definition: {
                        name: "Pulse Duration Output 4 B",
                        default: 5,
                        type: "numeric"
                    }
                }
            ]
        }
    ]
};
cbus.modules.definitions["CANACE8C"] = {
    manufacturerId: 165,
    moduleId: 5,
    name: "CANACE8C",
    configGroups: [
        {
            name: "General",
            nodeValues: [
                {
                    index: 1,
                    definition: {
                        name: "On/Off or On selection",
                        default: 0,
                        type: "bitfield"
                    }
                }, {
                    index: 2,
                    definition: {
                        name: "Invert input",
                        default: 0,
                        type: "bitfield"
                    }
                }, {
                    index: 3,
                    definition: {
                        name: "Enable input delay",
                        default: 0,
                        type: "bitfield"
                    }
                }, {
                    index: 4,
                    definition: {
                        name: "Input delay, ON time",
                        default: 10,
                        type: "numeric"
                    }
                }, {
                    index: 5,
                    definition: {
                        name: "Input delay, OFF time",
                        default: 10,
                        type: "numeric"
                    }
                }, {
                    index: 6,
                    definition: {
                        name: "Push button toggle",
                        default: 0,
                        type: "bitfield"
                    }
                }, {
                    index: 7,
                    definition: {
                        name: "Route options",
                        default: 0,
                        type: "numeric"
                    }
                }, {
                    index: 8,
                    definition: {
                        name: "Disable SOD",
                        default: 0,
                        type: "bitfield"
                    }
                }
            ]
        }
    ]
};
// Please see documentation at https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification
// for details on configuring this project to bundle and minify static web assets.

// Write your JavaScript code.


ko.applyBindings(window.cbus);

window.cbus.oncbusmessage = (msg) => {
    console.log(msg.DisplayString, msg);
};
